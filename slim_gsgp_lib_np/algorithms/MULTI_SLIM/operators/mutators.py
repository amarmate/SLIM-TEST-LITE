# MIT License
#
# Copyright (c) 2024 DALabNOVA
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
Mutator operator implementation.
"""

import random

from slim_gsgp_lib_np.algorithms.SLIM_GSGP.operators.mutators import exp
from slim_gsgp_lib_np.utils.utils import get_indices_with_levels, swap_sub_tree
from slim_gsgp_lib_np.algorithms.MULTI_SLIM.representations.tree_utils import (replace_subtree, get_subtree, collect_valid_subtrees,
                                                                               get_candidate_branch_indices, get_condition_indices, 
                                                                               get_specialist_indices, create_grow_random_tree)
from slim_gsgp_lib_np.algorithms.MULTI_SLIM.representations.condition import Condition
from slim_gsgp_lib_np.algorithms.MULTI_SLIM.representations.tree import Tree


# ------------------------------------------------------------ PRUNE MUTATION -------------------------------------------------------------- # 

def mutate_prune(tree, 
                 SPECIALISTS, 
                 FUNCTIONS):
    """
    Prune Mutation via Specialist Insertion.

    This function gathers candidate branch indices (only those where the branch is not already
    a specialist), randomly selects one candidate, and replaces that branch with a random specialist.
    If no candidate is found, it replaces the entire tree with a specialist.

    Parameters
    ----------
    tree : Tree object 
        A MULTI-SLIM ensemble tree
    SPECIALISTS : dict
        Dictionary of specialist individuals (keys used as terminals).
    FUNCTIONS : dict
        Dictionary of GP functions.

    Returns
    -------
    The new tree after pruning.
    """
    candidates = get_candidate_branch_indices(tree, path=[], FUNCTIONS=FUNCTIONS, SPECIALISTS=SPECIALISTS)
    if not candidates:
        # No candidate found: prune the entire tree.
        return Tree(random.choice(list(SPECIALISTS.keys())))
    chosen_path = random.choice(candidates)
    new_spec = random.choice(list(SPECIALISTS.keys()))
    new_tree = replace_subtree(tree, chosen_path, new_spec)
    return Tree(new_tree)

# ------------------------------------------------------------ EXPAND MUTATION -------------------------------------------------------------- #

def mutate_expand(tree, 
                  FUNCTIONS, 
                  TERMINALS, 
                  CONSTANTS, 
                  SPECIALISTS, 
                  depth_condition, 
                  max_depth,
                  p_c=0.3, 
                  p_t=0.5):
    """
    Mutation Operator: Expand Specialist.
    
    Given a tree, this function finds candidate indices where a specialist terminal is located.
    It then randomly selects one candidate and replaces that specialist with an ensemble node,
    which is composed of:
      - A new condition generated by create_grow_random_tree (using depth_condition),
      - Two new specialists (randomly chosen from SPECIALISTS) as the true and false branches.
    
    This expands the tree at that location.
    
    Parameters
    ----------
    tree : Tree object 
        A MULTI-SLIM ensemble tree
    FUNCTIONS : dict
        Dictionary of allowed GP functions.
    TERMINALS : dict
        Dictionary of terminal symbols.
    CONSTANTS : dict
        Dictionary of constant symbols.
    SPECIALISTS : dict
        Dictionary of specialist individuals.
    depth_condition : int
        Maximum depth for generating the new condition tree.
    max_depth : int
        Maximum depth of the ensemble tree.
    p_c : float, optional
        Constant probability for tree generation (passed to create_grow_random_tree). Default is 0.3.
    p_t : float, optional
        Terminal probability for tree generation (passed to create_grow_random_tree). Default is 0.5.
    
    Returns
    -------
    The mutated tree with one specialist expanded into an ensemble node.
    """
    # Get all indices where the node is a specialist terminal.
    collection = tree.collection
    candidate_indices = get_specialist_indices(collection, path=[], SPECIALISTS=SPECIALISTS)
    possible_indices = [possible[0] for possible in candidate_indices if possible[1] < max_depth]
    if not possible_indices:
        # No specialist found; nothing to expand.
        return tree
    chosen_path = random.choice(possible_indices)
    new_condition = create_grow_random_tree(depth_condition, FUNCTIONS, TERMINALS, CONSTANTS, p_c=p_c, p_t=p_t, first_call=True)
    new_condition = Condition(new_condition)
    new_spec1 = random.choice(list(SPECIALISTS.keys()))
    new_spec2 = random.choice(list(SPECIALISTS.keys()))
    new_subtree = (new_condition, new_spec1, new_spec2)
    new_tree = replace_subtree(collection, chosen_path, new_subtree)
    return Tree(new_tree)

# ----------------------------------------------------- SPECIALIST MUTATION ---------------------------------------------------------- #
def mutate_specialist(tree, SPECIALISTS):
    """
    Mutation Operator: Swap Specialist.
    
    This function finds all positions in the tree where a specialist terminal occurs.
    It randomly selects one such position and replaces the specialist with a different
    randomly chosen specialist from the SPECIALISTS dictionary.
    
    Parameters
    ----------
    tree : Tree object 
        A MULTI-SLIM ensemble tree
    SPECIALISTS : dict
        Dictionary of specialist individuals (the keys are used as terminals).
    
    Returns
    -------
    The new tree after swapping one specialist.
    """
    collection = tree.collection
    candidate_paths = get_specialist_indices(collection, path=[], SPECIALISTS=SPECIALISTS)
    if not candidate_paths: 
        # Specialist at the root node 
        return Tree(new_spec)
    
    candidates = list(SPECIALISTS.keys())
    new_spec = random.choice(candidates)
    chosen_path = random.choice(candidate_paths)[0]
    new_tree = replace_subtree(collection, chosen_path, new_spec)
    return Tree(new_tree)

# ----------------------------------------------------- CONDITION MUTATION ---------------------------------------------------------- #
def mutate_condition(tree, depth_condition, TERMINALS, CONSTANTS, FUNCTIONS, p_c=0.3, p_t=0.5, decay_rate=0.2):
    """
    Mutates a condition subtree by selecting one candidate condition node and then
    choosing an index within that node to replace with a new subtree.
    
    Process:
      1. Collect candidate paths to condition subtrees using get_condition_indices.
      2. Randomly choose one candidate path.
      3. Retrieve the candidate condition node (which should be a tuple).
      4. Randomly choose an index within that candidate tuple:
           - If index 0 is chosen, the entire candidate is replaced;
           - If index > 0 is chosen, then the allowed maximum depth is reduced by 1.
      5. Generate a new subtree using create_grow_random_tree with the appropriate maximum depth.
      6. Replace the subtree at the full path (candidate path + chosen index) with the new subtree.
    
    Parameters
    ----------
    tree : Tree object 
        A MULTI-SLIM ensemble tree
    depth_condition : int
        The maximum depth allowed for condition trees.
    TERMINALS : dict
        Dictionary of terminal symbols.
    CONSTANTS : dict
        Dictionary of constant symbols.
    FUNCTIONS : dict
        Dictionary of allowed GP functions.
    p_c : float
        Constant probability used in tree generation.
    p_t : float
        Terminal probability used in tree generation.
    decay_rate : float
        Rate at which the maximum depth is reduced when selecting a non-root index.

    
    Returns
    -------
    The mutated tree.
    """
    collection = tree.collection 
    candidate_paths = get_condition_indices(collection, path=[])
    if not candidate_paths:
        return tree
    
    candidate_path = random.choice(candidate_paths)
    candidate_tree = get_subtree(collection, candidate_path)

    # Now mutate the candidate tree.
    indices_with_levels = get_indices_with_levels(candidate_tree.repr_)
    random_index, depth = exp(candidate_tree.depth, depth_condition, indices_with_levels, decay_rate)

    # If just a node is selected
    if depth == 1: 
        if random.random() < p_c:
            new_subtree = random.choice(list(CONSTANTS.keys()))
        else:
            new_subtree = random.choice(list(TERMINALS.keys()))    
    else: 
        new_subtree = create_grow_random_tree(depth, FUNCTIONS, TERMINALS, CONSTANTS, p_c, p_t, first_call=True)

    new_condition = swap_sub_tree(candidate_tree.repr_, new_subtree, list(random_index))   
    new_condition = Condition(new_condition)
    new_tree = replace_subtree(collection, candidate_path, new_condition)
    return Tree(new_tree)

# ----------------------------------------------------- HOIST MUTATION ---------------------------------------------------------- #

def hoist_mutation(tree):
    """
    Performs hoist mutation on the tree.
    
    It collects all valid subtrees (complete ensemble nodes or specialist terminals),
    excludes the whole tree itself, and randomly selects one candidate to replace the
    entire tree.
    
    Parameters
    ----------
    tree : Tree object 
        A MULTI-SLIM ensemble tree
    
    Returns
    -------
    new_tree : tuple or any
        The mutated tree (i.e. one of the candidate subtrees) or the original tree if none exist.
    """
    collection = tree.collection
    candidates = collect_valid_subtrees(collection)
    # Exclude the entire tree from candidates.
    if collection in candidates:
        candidates.remove(collection)
    if not candidates:
        return tree
    return Tree(random.choice(candidates))

# ----------------------------------------------------- MUTATION ---------------------------------------------------------- #

def mutator(FUNCTIONS, TERMINALS, CONSTANTS, SPECIALISTS, 
            depth_condition, max_depth, 
            p_c=0.3, p_t=0.5, decay_rate=0.2):
    """
    Generate an aggregated mutation function that randomly selects a mutation 
    strategy among prune, expand, specialist, and condition mutation.

    Parameters
    ----------
    FUNCTIONS : dict
        Dictionary of GP functions.
    TERMINALS : dict
        Dictionary of terminal symbols.
    CONSTANTS : dict
        Dictionary of constant symbols.
    SPECIALISTS : dict
        Dictionary of specialist individuals (keys used as terminals).
    depth_condition : int
        Maximum depth for generating new condition trees (used in expand mutation).
    max_depth : int
        Maximum depth of the ensemble tree.
    p_c : float, optional
        Constant probability for tree generation (default is 0.3).
    p_t : float, optional
        Terminal probability for tree generation (default is 0.5).
    decay_rate : float, optional
        Decay rate used in condition mutation (default is 0.2).

    Returns
    -------
    Callable
        A mutation function that accepts a tree and returns a mutated tree.
    """
    def mutation(tree):
        r = random.random()
        if r < 0.1:
            return mutate_prune(tree, SPECIALISTS, FUNCTIONS)  
        elif r < 0.2:
            return mutate_expand(tree, FUNCTIONS, TERMINALS, CONSTANTS, SPECIALISTS, depth_condition, max_depth, p_c, p_t)
        elif r < 0.5:
            return mutate_specialist(tree, SPECIALISTS) 
        elif r < 0.8:
            return mutate_condition(tree, depth_condition, TERMINALS, CONSTANTS, FUNCTIONS, p_c, p_t, decay_rate) 
        else: 
            return hoist_mutation(tree)
    return mutation
